<?php 

//BRNRDPROJECT-REDBEAN - SOURCE CODE

/**

--- welcome to

                   .______.                         
_______   ____   __| _/\_ |__   ____ _____    ____  
\_  __ \_/ __ \ / __ |  | __ \_/ __ \\__  \  /    \ 
 |  | \/\  ___// /_/ |  | \_\ \  ___/ / __ \|   |  \
 |__|    \___  >____ |  |___  /\___  >____  /___|  /
             \/     \/      \/     \/     \/     \/ 



|RedBean Database Objects -
|Written by Gabor de Mooij (c) copyright 2009


|List of Contributors:
|Sean Hess 
|Alan Hogan
|Desfrenes

======================================================
|						       RedBean is Licensed BSD
------------------------------------------------------
|RedBean is a OOP Database Simulation Middleware layer
|for php.
------------------------------------------------------
|Loosely based on an idea by Erik Roelofs - thanks man

VERSION 0.5

======================================================
Official GIT HUB:
git://github.com/buurtnerd/redbean.git
http://github.com/buurtnerd/redbean/tree/master
======================================================



Copyright (c) 2009, G.J.G.T (Gabor) de Mooij
All rights reserved.

a Buurtnerd project


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
* Neither the name of the <organization> nor the
names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.

All advertising materials mentioning features or use of this software
are encouraged to display the following acknowledgement:
This product is powered by RedBean written by Gabor de Mooij (http://www.redbeanphp.com)


----




THIS SOFTWARE IS PROVIDED BY GABOR DE MOOIJ ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL GABOR DE MOOIJ BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



WARNING
THIS IS AN PRE-BETA VERSION, DONT USE THIS CODE ON PRODUCTION SERVERS

*/

class OODBBean { }
class RedBean_Can implements Iterator , ArrayAccess , SeekableIterator , Countable { private $collectionIDs = null; private $type = null; private $pointer = 0; private $num = 0; public function __construct( $type="", $collection = array() ) { $this->collectionIDs = $collection; $this->type = $type; $this->num = count( $this->collectionIDs ); } public function wrap( $bean ) { $dclass = PRFX.$this->type.SFFX; $deco = new $dclass( floatval( $bean->id ) ); $deco->setData( $bean ); return $deco; } public function count() { return $this->num; } public function getBeans() { $rows = RedBean_OODB::fastloader( $this->type, $this->collectionIDs ); $beans = array(); if (is_array($rows)) { foreach( $rows as $row ) { $beans[] = $this->wrap( RedBean_OODB::getById( $this->type, $id , $row) ); } } return $beans; } public function slice( $begin=0, $end=0 ) { $this->collectionIDs = array_slice( $this->collectionIDs, $begin, $end); $this->num = count( $this->collectionIDs ); } public function current() { if (isset($this->collectionIDs[$this->pointer])) { $id = $this->collectionIDs[$this->pointer]; return $this->wrap( RedBean_OODB::getById( $this->type, $id ) ); } else { return null; } } public function key() { return $this->pointer; } public function next() { return ++$this->pointer; } public function prev() { if ($this->pointer > 0) { return ++$this->pointer; }else { return 0; } } public function rewind() { $this->pointer=0; return 0; } public function seek( $seek ) { $this->pointer = (int) $seek; } public function valid() { return ($this->num > ($this->pointer+1)); } public function hasMoreBeans() { return $this->valid(); } public function offsetSet($offset, $value) { $this->collectionIDs[$offset] = $value; } public function offsetExists($offset) { return isset($this->collectionIDs[$offset]); } public function offsetUnset($offset) { unset($this->collectionIDs[$offset]); } public function offsetGet($offset) { if (isset($this->collectionIDs[$offset])) { $id = $this->collectionIDs[$offset]; return $this->wrap( RedBean_OODB::getById( $this->type, $id ) ); } else { return null; } } }
class RedBean_DBAdapter { private $db = null; public static $log = array(); public function __construct($database) { $this->db = $database; } public function escape( $sqlvalue ) { return $this->db->Escape($sqlvalue); } public function exec( $sql ) { self::$log[] = $sql; return $this->db->Execute( $sql ); } public function get( $sql ) { self::$log[] = $sql; return $this->db->GetAll( $sql ); } public function getRow( $sql ) { self::$log[] = $sql; return $this->db->GetRow( $sql ); } public function getCol( $sql ) { self::$log[] = $sql; return $this->db->GetCol( $sql ); } public function getCell( $sql ) { self::$log[] = $sql; $arr = $this->db->GetCol( $sql ); if ($arr && is_array($arr)) return ($arr[0]); else return false; } public function getInsertID() { return $this->db->getInsertID(); } public function getAffectedRows() { return $this->db->Affected_Rows(); } public function getDatabase() { return $this->db; } public function getErrorMsg() { return $this->db->Errormsg(); } }
class RedBean_Decorator { protected $data = null; protected $type = ""; protected $problems = array(); public function __construct( $type=false, $id=0, $lock=false ) { $id = floatval( $id ); if (!$type) { throw new Exception("Undefined bean type"); } else { $this->type = preg_replace( "[\W_]","", strtolower($type)); if ($id > 0) { $this->data = RedBean_OODB::getById( $this->type, $id, $lock ); } else { $this->data = RedBean_OODB::dispense( $this->type ); } } } public function free( $property ) { RedBean_OODB::dropColumn( $this->type, $property ); } public function importFromPost( $selection=null ) { if (!$selection) { $selection = array_keys($_POST); } if (is_string($selection)) { $selection = explode(",",$selection); } if ($selection && is_array($selection) && count($selection) > 0) { foreach( $selection as $field ) { $setter = "set".ucfirst( $field ); if (isset( $_POST[$field] )) { $resp = $this->$setter( $_POST[ $field ] ); if ($resp !== true) { $this->problems[$field] = $resp; } } } if (count($this->problems)===0) { return true; } else { return false; } } } public function import( $arr ) { foreach( $arr as $key=>$val ) { $setter = "set".ucfirst( $key ); $resp = $this->$setter( $val ); if ($resp !== true) { $this->problems[$key] = $resp; } } if (count($this->problems)===0) { return true; } else { return false; } } public function problems() { return $this->problems; } public function __call( $method, $arguments ) { return $this->command( $method, $arguments ); } public function __get( $name ) { $name = strtolower( $name ); return isset($this->data->$name) ? $this->data->$name : null; } public function __set( $name, $value ) { $name = strtolower( $name ); $this->data->$name = $value; } public function command( $method, $arguments ) { if (strpos( $method,"set" ) === 0) { $prop = substr( $method, 3 ); $this->$prop = $arguments[0]; return $this; } elseif (strpos($method,"getRelated")===0) { $prop = strtolower( substr( $method, 10 ) ); $beans = RedBean_OODB::getAssoc( $this->data, $prop ); $decos = array(); $dclass = PRFX.$prop.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } return $decos; } elseif (strpos( $method, "get" ) === 0) { $prop = substr( $method, 3 ); return $this->$prop; } elseif (strpos( $method, "is" ) === 0) { $prop = strtolower( substr( $method, 2 ) ); return ($this->data->$prop ? TRUE : FALSE); } else if (strpos($method,"add") === 0) { $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::associate($this->data, $bean); return $this; } else if (strpos($method,"remove")===0) { $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::unassociate($this->data, $bean); return $this; } else if (strpos($method,"attach")===0) { $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::addChild($this->data, $bean); return $this; } else if (strpos($method,"clearRelated")===0) { $type = strtolower( substr( $method, 12 ) ); RedBean_OODB::deleteAllAssocType($type, $this->data); return $this; } else if (strpos($method,"numof")===0) { $type = strtolower( substr( $method, 5 ) ); return RedBean_OODB::numOfRelated($type, $this->data); } } public function belongsTo( $deco ) { RedBean_OODB::deleteAllAssocType($deco->getType(), $this->data); RedBean_OODB::associate($this->data, $deco->getData()); } public function exclusiveAdd( $deco ) { RedBean_OODB::deleteAllAssocType($this->type,$deco->getData()); RedBean_OODB::associate($deco->getData(), $this->data); } public function parent() { $beans = RedBean_OODB::getParent( $this->data ); if (count($beans) > 0 ) $bean = array_pop($beans); else return null; $dclass = PRFX.$this->type.SFFX; $deco = new $dclass(); $deco->setData( $bean ); return $deco; } public function siblings() { $beans = RedBean_OODB::getParent( $this->data ); if (count($beans) > 0 ) { $bean = array_pop($beans); } else { return null; } $beans = RedBean_OODB::getChildren( $bean ); $decos = array(); $dclass = PRFX.$this->type.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { if ($b->id != $this->data->id) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } } return $decos; } public function children() { $beans = RedBean_OODB::getChildren( $this->data ); $decos = array(); $dclass = PRFX.$this->type.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } return $decos; } public function hasParent( $deco ) { $me = $this; while( $parent = $me->parent() ) { if ($deco->getID() == $parent->getID()) { return true; } else { $me = $parent; } } return false; } public function hasChild( $deco ) { $nodes = array($this); while($node = array_shift($nodes)) { if ($node->getID() == $deco->getID() && ($node->getID() != $this->getID())) { return true; } if ($children = $node->children()) { $nodes = array_merge($nodes, $children); } } return false; } public function hasSibling( $deco ) { $siblings = $this->siblings(); foreach( $siblings as $sibling ) { if ($sibling->getID() == $deco->getID()) { return true; } } return false; } public function copy() { $clone = new self( $this->type, 0 ); $clone->setData( $this->getData() ); return $clone; } public function clearAllRelations() { RedBean_OODB::deleteAllAssoc( $this->getData() ); } public function getData() { return $this->data; } public function setData( $data ) { $this->data = $data; } public function save() { return RedBean_OODB::set( $this->data ); } public static function delete( $deco ) { RedBean_OODB::trash( $deco->getData() ); } public function lock() { RedBean_OODB::openBean($this->getData()); } public function unlock() { RedBean_OODB::closeBean( $this->getData()); } public static function close( $deco ) { RedBean_OODB::closeBean( $deco->getData() ); } public static function make( $type="", $id ){ return new RedBean_Decorator( $type, $id ); } public function exportTo( &$bean, $overridebean=false ) { foreach($this->data as $prop=>$value) { if (is_object($overridebean) && isset($overridebean->$prop)) { $value = $overridebean->$prop; } elseif (is_array($overridebean) && isset($overridebean[$prop])) { $value = $overridebean[$prop]; } if (is_object($value)){ $value = $value->getID(); } if (is_object($bean)) { $bean->$prop = $value; } elseif (is_array($bean)) { $bean[$prop] = $value; } } return $bean; } public function exportAsArr() { $arr = array(); foreach($this->data as $prop=>$value) { if ($value instanceof RedBean_Decorator){ $value = $value->getID(); } $arr[ $prop ] = $value; } return $arr; } public static function find( $deco, $filter, $start=0, $end=100, $orderby=" id ASC ", $extraSQL=false ) { if (!is_array($filter)) { return array(); } if (count($filter)<1) { return array(); } $filters = array(); foreach($filter as $key=>$f) { $filters[strtolower($key)] =$f; if (!in_array($f,array("=","!=","<",">","<=",">=","like","LIKE"))) { throw new ExceptionInvalidFindOperator(); } } $beans = RedBean_OODB::find( $deco->getData(), $filters, $start, $end, $orderby, $extraSQL ); $decos = array(); $dclass = PRFX.$deco->type.SFFX; foreach( $beans as $bean ) { $decos[ $bean->id ] = new $dclass( floatval( $bean->id ) ); $decos[ $bean->id ]->setData( $bean ); } return $decos; } }
class Redbean_Driver_PDO implements RedBean_Driver { private static $instance; private $debug = false; private $pdo; private $affected_rows; private $rs; public static function getInstance($dsn, $user, $pass, $dbname) { if(is_null(self::$instance)) { self::$instance = new Redbean_Driver_PDO($dsn, $user, $pass); } return self::$instance; } public function __construct($dsn, $user, $pass) { $this->pdo = new PDO( $dsn, $user, $pass, array(PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8', PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC) ); } public function GetAll( $sql ) { try{ if ($this->debug) { echo "<HR>" . $sql; } $rs = $this->pdo->query($sql); $this->rs = $rs; $rows = $rs->fetchAll(); if(!$rows) { $rows = array(); } if ($this->debug) { if (count($rows) > 0) { echo "<br><b style='color:green'>resultset: " . count($rows) . " rows</b>"; } $str = $this->Errormsg(); if ($str != "") { echo "<br><b style='color:red'>" . $str . "</b>"; } } } catch(Exception $e){ return array(); } return $rows; } public function GetCol($sql) { try{ $rows = $this->GetAll($sql); $cols = array(); if ($rows && is_array($rows) && count($rows)>0){ foreach ($rows as $row) { $cols[] = array_shift($row); } } } catch(Exception $e){ return array(); } return $cols; } public function GetCell($sql) { try{ $arr = $this->GetAll($sql); $row1 = array_shift($arr); $col1 = array_shift($row1); } catch(Exception $e){} return $col1; } public function GetRow($sql) { try{ $arr = $this->GetAll($sql); } catch(Exception $e){ return array(); } return array_shift($arr); } public function ErrorNo() { $infos = $this->pdo->errorInfo(); return $infos[1]; } public function Errormsg() { $infos = $this->pdo->errorInfo(); return $infos[2]; } public function Execute( $sql ) { try{ if ($this->debug) { echo "<HR>" . $sql; } $this->affected_rows = $this->pdo->exec($sql); if ($this->debug) { $str = $this->Errormsg(); if ($str != "") { echo "<br><b style='color:red'>" . $str . "</b>"; } } } catch(Exception $e){ return 0; } return $this->affected_rows; } public function Escape( $str ) { return substr(substr($this->pdo->quote($str), 1), 0, -1); } public function GetInsertID() { return (int) $this->pdo->lastInsertId(); } public function Affected_Rows() { return (int) $this->affected_rows; } public function setDebugMode( $tf ) { $this->debug = (bool)$tf; } public function GetRaw() { return $this->rs; } }
interface RedBean_Driver { public static function getInstance( $host, $user, $pass, $dbname ); public function GetAll( $sql ); public function GetCol( $sql ); public function GetCell( $sql ); public function GetRow( $sql ); public function ErrorNo(); public function Errormsg(); public function Execute( $sql ); public function Escape( $str ); public function GetInsertID(); public function Affected_Rows(); public function setDebugMode( $tf ); public function GetRaw(); }
class ExceptionFailedAccessBean extends Exception{}
class ExceptionInvalidArgument extends RedBean_Exception {}
class ExceptionRedBeanSecurity extends RedBean_Exception {}
class ExceptionInvalidParentChildCombination extends RedBean_Exception{}
class ExceptionSQL extends RedBean_Exception {};
class Redbean_Exception extends Exception{}
class RedBean_OODB { private static $version = 0.5; private static $versioninf = "
		RedBean Object Database layer 
		VERSION 0.5
		BY G.J.G.T DE MOOIJ
		LICENSE BSD
		COPYRIGHT 2009
	"; private static $locktime = 10; public static $db; private static $locking = true; public static $typeno_sqltype = array( " TINYINT(3) UNSIGNED ", " INT(11) UNSIGNED ", " BIGINT(20) SIGNED ", " VARCHAR(255) ", " TEXT ", " LONGTEXT " ); public static $sqltype_typeno = array( "tinyint(3) unsigned"=>0, "int(11) unsigned"=>1, "bigint(20) signed"=>2, "varchar(255)"=>3, "text"=>4, "longtext"=>5 ); public static $dtypes = array( "tintyintus","intus","ints","varchar255","text","ltext" ); public static $pkey = false; private static $me = null; private static $engine = "myisam"; private static $frozen = false; public function __destruct() { if (self::$engine === "innodb") { self::$db->exec("COMMIT"); } else if (self::$engine === "myisam"){ } RedBean_OODB::releaseAllLocks(); } public static function getVersionInfo() { return self::$versioninf; } public static function getVersionNumber() { return self::$version; } public static function setLocking( $tf ) { self::$locking = $tf; } public static function getLocking() { return self::$locking; } public static function setOptimizerActive( $bool ) { self::$optimizer = (boolean) $bool; } public static function getOptimizerActive() { return self::$optimizer; } public static function checkBean(OODBBean $bean) { foreach($bean as $prop=>$value) { $prop = preg_replace('/[^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]/',"",$prop); if (strlen(trim($prop))===0) { throw new ExceptionRedBeanSecurity("Invalid Characters in property"); } else { $bean->$prop = $value; } } if (!self::$pkey) self::init(); if (!isset($bean->id)) { throw new Exception("Invalid bean, no id"); } if (!is_numeric($bean->id)) { throw new Exception("Invalid bean, id not numeric"); } if (!isset($bean->type)) { throw new Exception("Invalid bean, no type"); } if (!is_string($bean->type) || is_numeric($bean->type) || strlen($bean->type)<3) { throw new Exception("Invalid bean, wrong type"); } if ($bean->type==="locking" || $bean->type==="dtyp") { throw new Exception("Beantype is reserved table"); } if (strpos($bean->type,"_")!==false && ctype_alnum($bean->type)) { throw new Exception("Beantype contains illegal characters"); } } public static function checkBeanForAssoc( $bean ) { self::checkBean($bean); if (intval($bean->id) < 1) { $bean->id = self::set( $bean ); } return $bean; } public static function getEngine() { return self::$engine; } public static function setEngine( $engine ) { if ($engine=="myisam" || $engine=="innodb") { self::$engine = $engine; } else { throw new Exception("Unsupported database engine"); } return self::$engine; } public static function set( OODBBean $bean ) { self::checkBean($bean); $db = self::$db; $table = $db->escape($bean->type); if (!self::$frozen) { $tables = self::showTables(); if (!in_array($table, $tables)) { if (self::$engine=="myisam") { $createtableSQL = "
					 CREATE TABLE `$table` (
					`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
					 PRIMARY KEY ( `id` )
					 ) ENGINE = MYISAM 
					"; } else { $createtableSQL = "
					 CREATE TABLE `$table` (
					`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
					 PRIMARY KEY ( `id` )
					 ) ENGINE = InnoDB 
					"; } $db->exec( $createtableSQL ); self::addTable( $table ); } $columnsRaw = $db->get("describe `$table` "); $columns = array(); foreach($columnsRaw as $r) { $columns[$r["Field"]]=$r["Type"]; } $insertvalues = array(); $insertcolumns = array(); $updatevalues = array(); foreach( $bean as $p=>$v) { if ($p!="type" && $p!="id") { $p = $db->escape($p); $v = $db->escape($v); $typeno = self::inferType($v); if (isset($columns[$p])) { $sqlt = self::getType($columns[$p]); if ($typeno > $sqlt) { $changecolumnSQL="ALTER TABLE `$table` CHANGE `$p` `$p` ".self::$typeno_sqltype[$typeno]; $db->exec( $changecolumnSQL ); } } else { $addcolumnSQL = "ALTER TABLE `$table` ADD `$p` ".self::$typeno_sqltype[$typeno]; $db->exec( $addcolumnSQL ); } $insertvalues[] = "\"".$v."\""; $insertcolumns[] = "`".$p."`"; $updatevalues[] = " `$p`=\"$v\" "; } } } else { foreach( $bean as $p=>$v) { if ($p!="type" && $p!="id") { $p = $db->escape($p); $v = $db->escape($v); $insertvalues[] = "\"".$v."\""; $insertcolumns[] = "`".$p."`"; $updatevalues[] = " `$p`=\"$v\" "; } } } if ($bean->id) { self::openBean($bean, true); if (count($updatevalues)>0) { $updateSQL = "UPDATE `$table` SET ".implode(",",$updatevalues)."WHERE id = ".$bean->id; $db->exec( $updateSQL ); } } else { if (count($insertvalues)>0) { $insertSQL = "INSERT INTO `$table` "; $insertSQL .= " ( id, ".implode(",",$insertcolumns)." ) "; $insertSQL .= " VALUES( null, ".implode(",",$insertvalues)." ) "; } else { $insertSQL = "INSERT INTO `$table` VALUES(null) "; } $db->exec( $insertSQL ); $bean->id = $db->getInsertID(); self::openBean($bean); } return $bean->id; } public static function inferType( $v ) { $db = self::$db; $rawv = $v; $v = "'".$db->escape(strval($v))."'"; $checktypeSQL = "insert into dtyp VALUES(null,$v,$v,$v,$v,$v )"; $db->exec( $checktypeSQL ); $id = $db->getInsertID(); $readtypeSQL = "select tinyintus,intus,ints,varchar255,`text` from dtyp where id=$id"; $row=$db->getRow($readtypeSQL); $db->exec("truncate table dtyp"); $tp = 0; foreach($row as $t=>$tv) { if (strval($tv) === strval($rawv)) { return $tp; } $tp++; } return $tp; } public static function getType( $sqlType ) { if (in_array($sqlType,self::$sqltype_typeno)) { $typeno = self::$sqltype_typeno[$sqlType]; } else { $typeno = -1; } return $typeno; } public static function init( $dontclose = false) { self::$me = new RedBean_OODB(); if (self::$engine === "innodb") { self::$db->exec("SET autocommit=0"); self::$db->exec("START TRANSACTION"); } else if (self::$engine === "myisam"){ self::$db->exec("SET autocommit=1"); } if (!self::$frozen) { self::$db->exec("drop tables dtyp"); self::$db->exec("
				CREATE TABLE IF NOT EXISTS `dtyp` (
				  `id` int(11) unsigned NOT NULL auto_increment,
				  `tinyintus` tinyint(3) unsigned NOT NULL,
				  `intus` int(11) unsigned NOT NULL,
				  `ints` bigint(20) NOT NULL,
				  
				  `varchar255` varchar(255) NOT NULL,
				  `text` text NOT NULL,
				  PRIMARY KEY  (`id`)
				) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
				"); self::$db->exec("
				CREATE TABLE IF NOT EXISTS `locking` (
				  `tbl` varchar(255) NOT NULL,
				  `id` bigint(20) NOT NULL,
				  `fingerprint` varchar(255) NOT NULL,
				  `expire` int(11) NOT NULL,
				  UNIQUE KEY `tbl` (`tbl`,`id`)
				) ENGINE=MyISAM DEFAULT CHARSET=latin1;
				"); self::$db->exec("
				 CREATE TABLE IF NOT EXISTS `redbeantables` (
				 `id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				 `tablename` VARCHAR( 255 ) NOT NULL ,
				 PRIMARY KEY ( `id` ),
				 UNIQUE KEY `tablename` (`tablename`)
				 ) ENGINE = MYISAM 
				"); self::$db->exec("
				 CREATE TABLE IF NOT EXISTS `searchindex` (
				`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				`ind` VARCHAR( 255 ) NOT NULL ,
				`cnt` INT( 11 ) NOT NULL ,
				PRIMARY KEY ( `id` ),
				UNIQUE KEY `ind` (`ind`)
				) ENGINE = MYISAM "); } if (!self::$pkey) { self::$pkey = str_replace(".","",microtime(true)."".mt_rand()); } return true; } public static function freeze() { self::$frozen = true; } public static function unfreeze() { self::$frozen = false; } public static function showTables( $all=false ) { $db = self::$db; if ($all && self::$frozen) { $alltables = $db->getCol("show tables"); return $alltables; } else { $alltables = $db->getCol("select tablename from redbeantables"); return $alltables; } } public static function addTable( $tablename ) { $db = self::$db; $tablename = $db->escape( $tablename ); $db->exec("replace into redbeantables values (null, \"$tablename\") "); } public static function dropTable( $tablename ) { $db = self::$db; $tablename = $db->escape( $tablename ); $db->exec("delete from redbeantables where tablename = \"$tablename\" "); } public function releaseAllLocks() { self::$db->exec("DELETE FROM locking WHERE fingerprint=\"".self::$pkey."\" "); } public static function openBean( $bean, $mustlock=false) { self::checkBean( $bean ); if (!self::$locking || $bean->id === 0) return true; $db = self::$db; $removeExpiredSQL = "DELETE FROM locking WHERE expire < ".(time()-self::$locktime); $db->exec($removeExpiredSQL); $tbl = $db->escape( $bean->type ); $id = intval( $bean->id ); $checkopenSQL = "SELECT id FROM locking WHERE id=$id AND  tbl=\"$tbl\" AND fingerprint=\"".self::$pkey."\" "; $row = $db->getRow($checkopenSQL); if ($row && is_array($row) && count($row)>0) { $updateexpstamp = "UPDATE locking SET expire=".time()." WHERE id =".$row["id"]; return true; } if ($mustlock) { throw new ExceptionFailedAccessBean("Could not acquire a lock for bean $tbl . $id "); return false; } $openSQL = "INSERT INTO locking VALUES(\"$tbl\",$id,\"".self::$pkey."\",\"".time()."\") "; $trials = 0; $aff = 0; while( $aff < 1 && $trials < 5 ) { $db->exec($openSQL); $aff = $db->getAffectedRows(); $trials++; if ($aff < 1) usleep(500000); } if ($trials > 4) { return false; } else { return true; } } private static function sync( $toggle ) { $bean = RedBean_OODB::dispense("_syncmethod"); $bean->id = 0; if ($toggle) { self::openBean( $bean ); } else { self::closeBean( $bean ); } } public static function getById($type, $id, $data=false) { $bean = self::dispense( $type ); $db = self::$db; $table = $db->escape( $type ); $id = intval( $id ); $bean->id = $id; self::openBean($bean); if (!$data) { $getSQL = "SELECT * FROM `$type` WHERE id = $id "; $row = $db->getRow( $getSQL ); } else { $row = $data; } if ($row && is_array($row) && count($row)>0) { foreach($row as $p=>$v) { $bean->$p = $v; } } else { throw new ExceptionFailedAccessBean("bean not found"); } return $bean; } public static function exists($type,$id) { $db = self::$db; $id = intval( $id ); $type = $db->escape( $type ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return false; } else { $no = $db->getCell("select count(*) from `$type` where id=$id"); if (intval($no)) { return true; } else { return false; } } } public static function numberof($type) { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return 0; } else { $no = $db->getCell("select count(*) from `$type`"); return $no; } } static function distinct($type, $field) { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $field = $db->escape( $field ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return array(); } else { $ids = $db->getCol("SELECT id FROM `$type` GROUP BY $field"); $beans = array(); if (is_array($ids) && count($ids)>0) { foreach( $ids as $id ) { $beans[ $id ] = self::getById( $type, $id , false); } } return $beans; } } private static function stat($type,$field,$stat="sum") { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $field = strtolower( $db->escape( $field ) ); $stat = $db->escape( $stat ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return 0; } else { $no = $db->getCell("select $stat(`$field`) from `$type`"); return $no; } } public static function sumof($type,$field) { return self::stat( $type, $field, "sum"); } public static function avgof($type,$field) { return self::stat( $type, $field, "avg"); } public static function minof($type,$field) { return self::stat( $type, $field, "min"); } public static function maxof($type,$field) { return self::stat( $type, $field, "max"); } public static function resetAll() { $sql = "TRUNCATE locking"; self::$db->exec( $sql ); return true; } public static function processQuerySlots($sql, $slots) { $db = self::$db; $code = sha1(rand(1,1000)*time()); foreach( $slots as $key=>$value ) { $sql = str_replace( "{".$key."}", "{".$code.$key."}" ,$sql ); } foreach( $slots as $key=>$value ) { $sql = str_replace( "{".$code.$key."}", "\"".$db->escape( $value )."\"",$sql ); } return $sql; } public static function fastLoader( $type, $ids ) { $db = self::$db; $sql = "SELECT * FROM `$type` WHERE id IN ( ".implode(",", $ids)." ) ORDER BY FIELD(id,".implode(",", $ids).") ASC
			"; return $db->get( $sql ); } public static function getBySQL( $rawsql, $slots, $table ) { $db = self::$db; $sql = $rawsql; if (is_array($slots)) { $sql = self::processQuerySlots( $sql, $slots ); } $rs = $db->getCol( "select `$table`.id from $table where " . $sql ); if (is_array($rs)) { return $rs; } else { return array(); } } public static function find(OODBBean $bean, $searchoperators = array(), $start=0, $end=100, $orderby="id ASC", $extraSQL=false) { self::checkBean( $bean ); $db = self::$db; $tbl = $db->escape( $bean->type ); $findSQL = "SELECT id FROM `$tbl` WHERE "; foreach($bean as $p=>$v) { if ($p === "type" || $p === "id") continue; $p = $db->escape($p); $v = $db->escape($v); if (isset($searchoperators[$p])) { if ($searchoperators[$p]==="LIKE") { $part[] = " `$p`LIKE \"%$v%\" "; } else { $part[] = " `$p` ".$searchoperators[$p]." \"$v\" "; } } else { } } if ($extraSQL) { $findSQL .= @implode(" AND ",$part) . $extraSQL; } else { $findSQL .= @implode(" AND ",$part) . " ORDER BY $orderby LIMIT $start, $end "; } $ids = $db->getCol( $findSQL ); $beans = array(); if (is_array($ids) && count($ids)>0) { foreach( $ids as $id ) { $beans[ $id ] = self::getById( $bean->type, $id , false); } } return $beans; } public static function listAll($type, $start=false, $end=false, $orderby="id ASC", $extraSQL = false) { $db = self::$db; if ($extraSQL) { $listSQL = "SELECT * FROM ".$db->escape($type)." ".$extraSQL; } else { $listSQL = "SELECT * FROM ".$db->escape($type)."
					ORDER BY ".$orderby; if ($end !== false && $start===false) { $listSQL .= " LIMIT ".intval($end); } if ($start !== false && $end !== false) { $listSQL .= " LIMIT ".intval($start).", ".intval($end); } if ($start !== false && $end===false) { $listSQL .= " LIMIT ".intval($start).", 18446744073709551615 "; } } return $db->get( $listSQL ); } public static function associate( OODBBean $bean1, OODBBean $bean2 ) { $db = self::$db; $bean1 = self::checkBeanForAssoc($bean1); $bean2 = self::checkBeanForAssoc($bean2); self::openBean( $bean1, true ); self::openBean( $bean2, true ); $tp1 = $bean1->type; $tp2 = $bean2->type; if ($tp1==$tp2){ $arr = array( 0=>$bean1, 1 =>$bean2 ); } else { $arr = array( $tp1=>$bean1, $tp2 =>$bean2 ); } ksort($arr); $bean1 = array_shift( $arr ); $bean2 = array_shift( $arr ); $id1 = intval($bean1->id); $id2 = intval($bean2->id); $tables = array(); array_push( $tables, $db->escape( $bean1->type ) ); array_push( $tables, $db->escape( $bean2->type ) ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); if (!self::$frozen) { $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { $t1 = $tables[0]; $t2 = $tables[1]; if ($t1==$t2) { $t2.="2"; } $assoccreateSQL = "
				 CREATE TABLE `$assoctable` (
				`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				`".$t1."_id` INT( 11 ) UNSIGNED NOT NULL,
				`".$t2."_id` INT( 11 ) UNSIGNED NOT NULL,
				 PRIMARY KEY ( `id` )
				 ) ENGINE = ".self::$engine."; 
				"; $db->exec( $assoccreateSQL ); $db->exec( "ALTER TABLE `$assoctable` ADD UNIQUE INDEX `u_$assoctable` (`".$t1."_id`, `".$t2."_id` ) " ); self::addTable( $assoctable ); } } $assocSQL = "REPLACE INTO `$assoctable` VALUES(null,$id1,$id2) "; $db->exec( $assocSQL ); } public static function unassociate(OODBBean $bean1, OODBBean $bean2) { $db = self::$db; $bean1 = self::checkBeanForAssoc($bean1); $bean2 = self::checkBeanForAssoc($bean2); self::openBean( $bean1, true ); self::openBean( $bean2, true ); $idx1 = intval($bean1->id); $idx2 = intval($bean2->id); $tp1 = $bean1->type; $tp2 = $bean2->type; if ($tp1==$tp2){ $arr = array( 0=>$bean1, 1 =>$bean2 ); } else { $arr = array( $tp1=>$bean1, $tp2 =>$bean2 ); } ksort($arr); $bean1 = array_shift( $arr ); $bean2 = array_shift( $arr ); $id1 = intval($bean1->id); $id2 = intval($bean2->id); $tables = array(); array_push( $tables, $db->escape( $bean1->type ) ); array_push( $tables, $db->escape( $bean2->type ) ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $alltables = self::showTables(); if (in_array($assoctable, $alltables)) { $t1 = $tables[0]; $t2 = $tables[1]; if ($t1==$t2) { $t2.="2"; $unassocSQL = "DELETE FROM `$assoctable` WHERE ".$t2."_id = $id1 AND ".$t1."_id = $id2 "; $db->exec($unassocSQL); } $unassocSQL = "DELETE FROM `$assoctable` WHERE ".$t1."_id = $id1 AND ".$t2."_id = $id2 "; $db->exec($unassocSQL); } if ($tp1==$tp2) { $assoctable2 = "pc_".$db->escape( $bean1->type )."_".$db->escape( $bean1->type ); $alltables = self::showTables(); if (in_array($assoctable2, $alltables)) { $unassocSQL = "DELETE FROM `$assoctable2` WHERE
				(parent_id = $idx1 AND child_id = $idx2) OR
				(parent_id = $idx2 AND child_id = $idx1) "; $db->exec($unassocSQL); } } } public static function getAssoc(OODBBean $bean, $targettype) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); $id = intval($bean->id); $t1 = $db->escape( strtolower($bean->type) ); $t2 = $db->escape( $targettype ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { if ($t1==$t2) { $t2.="2"; } $getassocSQL = "SELECT `".$t2."_id` FROM `$assoctable` WHERE `".$t1."_id` = $id "; $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function trash( OODBBean $bean ) { self::checkBean( $bean ); if (intval($bean->id)===0) return; self::deleteAllAssoc( $bean ); self::openBean($bean); self::$db->exec( "DELETE FROM ".self::$db->escape($bean->type)." WHERE id = ".intval($bean->id) ); } public static function deleteAllAssoc( $bean ) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); self::openBean( $bean, true ); $id = intval( $bean->id ); $alltables = self::showTables(); $t = $db->escape($bean->type); $checktables = array(); foreach( $alltables as $table ) { if (strpos($table,$t."_")!==false || strpos($table,"_".$t)!==false){ $checktables[] = $table; } } foreach($checktables as $table) { if (strpos($table,"pc_")===0){ $db->exec("DELETE FROM $table WHERE parent_id = $id OR child_id = $id "); } else { $db->exec("DELETE FROM $table WHERE ".$t."_id = $id "); $db->exec("DELETE FROM $table WHERE ".$t."2_id = $id "); } } return true; } public static function deleteAllAssocType( $targettype, $bean ) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); self::openBean( $bean, true ); $id = intval( $bean->id ); $t1 = $db->escape( strtolower($bean->type) ); $t2 = $db->escape( $targettype ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); if (strpos($assoctable,"pc_")===0){ $db->exec("DELETE FROM $assoctable WHERE parent_id = $id  OR child_id = $id "); }else{ $db->exec("DELETE FROM $assoctable WHERE ".$t1."_id = $id "); $db->exec("DELETE FROM $assoctable WHERE ".$t1."2_id = $id "); } return true; } public static function dispense( $type="StandardBean" ) { $oBean = new OODBBean(); $oBean->type = $type; $oBean->id = 0; return $oBean; } public static function addChild( OODBBean $parent, OODBBean $child ) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $child = self::checkBeanForAssoc($child); self::openBean( $parent, true ); self::openBean( $child, true ); if ($parent->type !== $child->type) { throw new ExceptionInvalidParentChildCombination(); } $pid = intval($parent->id); $cid = intval($child->id); $assoctable = "pc_".$db->escape($parent->type."_".$parent->type); if (!self::$frozen) { $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { $assoccreateSQL = "
				 CREATE TABLE `$assoctable` (
				`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				`parent_id` INT( 11 ) UNSIGNED NOT NULL,
				`child_id` INT( 11 ) UNSIGNED NOT NULL,
				 PRIMARY KEY ( `id` )
				 ) ENGINE = ".self::$engine."; 
				"; $db->exec( $assoccreateSQL ); $db->exec( "ALTER TABLE `$assoctable` ADD UNIQUE INDEX `u_$assoctable` (`parent_id`, `child_id` ) " ); self::addTable( $assoctable ); } } $assocSQL = "REPLACE INTO `$assoctable` VALUES(null,$pid,$cid) "; $db->exec( $assocSQL ); } public static function getChildren( OODBBean $parent ) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $pid = intval($parent->id); $assoctable = "pc_".$db->escape( $parent->type . "_" . $parent->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { $targettype = $parent->type; $getassocSQL = "SELECT `child_id` FROM `$assoctable` WHERE `parent_id` = $pid "; $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function getParent( OODBBean $child ) { $db = self::$db; $child = self::checkBeanForAssoc($child); $cid = intval($child->id); $assoctable = "pc_".$db->escape( $child->type . "_" . $child->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { $targettype = $child->type; $getassocSQL = "SELECT `parent_id` FROM `$assoctable` WHERE `child_id` = $cid "; $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function removeChild(OODBBean $parent, OODBBean $child) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $child = self::checkBeanForAssoc($child); self::openBean( $parent, true ); self::openBean( $child, true ); if ($parent->type !== $child->type) { throw new ExceptionInvalidParentChildCombination(); } $assoctable = "pc_".$db->escape( $parent->type . "_" . $parent->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return true; } else { $pid = intval($parent->id); $cid = intval($child->id); $unassocSQL = "DELETE FROM `$assoctable` WHERE
				( parent_id = $pid AND child_id = $cid ) "; $db->exec($unassocSQL); } } public static function numofRelated( $type, OODBBean $bean ) { $db = self::$db; $t2 = strtolower( $db->escape( $type ) ); self::checkBean( $bean ); $t1 = strtolower( $bean->type ); $tref = strtolower( $db->escape( $bean->type ) ); $id = intval( $bean->id ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $tables = self::showTables(); if ($tables && is_array($tables) && count($tables) > 0) { if (in_array( $t1, $tables ) && in_array($t2, $tables)){ $sqlCountRelations = "
						SELECT COUNT(1) 
						FROM `$assoctable` WHERE 
						".$t1."_id = $id
					"; return (int) $db->getCell( $sqlCountRelations ); } } else { return 0; } } public static function gen( $classes ) { $classes = explode(",",$classes); foreach($classes as $c) { if ($c!=="" && $c!=="null" && !class_exists($c) && preg_match("/^\s*[A-Za-z_][A-Za-z0-9_]*\s*$/",$c)){ try{ eval("final class ".$c." extends RedBean_Decorator {
							private static \$__static_property_type = \"".strtolower($c)."\";
							
							public function __construct(\$id=0, \$lock=false) {
								parent::__construct('".strtolower($c)."',\$id,\$lock);
							}
							
							//no late static binding... great..
							public static function where( \$sql, \$slots=array() ) {
								return new RedBean_Can( self::\$__static_property_type, RedBean_OODB::getBySQL( \$sql, \$slots, self::\$__static_property_type) );
							}
	
							public static function listAll(\$start=false,\$end=false,\$orderby=' id ASC ',\$sql=false) {
								return RedBean_OODB::listAll(self::\$__static_property_type,\$start,\$end,\$orderby,\$sql);
							}
							
					}"); if (!class_exists($c)) return false; } catch(Exception $e){ return false; } } else { return false; } } return true; } public static function setLockingTime( $timeInSecs ) { if (is_int($timeInSecs) && $timeInSecs >= 0) { self::$locktime = $timeInSecs; } else { throw new ExceptionInvalidArgument( "time must be integer >= 0" ); } } public static function clean() { if (self::$frozen) { return false; } $db = self::$db; $tables = $db->getCol("select tablename from redbeantables"); foreach($tables as $key=>$table) { $tables[$key] = "`".$table."`"; } $sqlcleandatabase = "drop tables ".implode(",",$tables); $db->exec( $sqlcleandatabase ); $db->exec( "truncate redbeantables" ); self::resetAll(); return true; } public static function removeUnused( ) { if (self::$frozen) { return false; } $db = self::$db; $tables = self::showTables(); foreach($tables as $table) { $classname = PRFX . $table . SFFX; if(!class_exists( $classname , true)) { $db->exec("DROP TABLE `$table`;"); $db->exec("DELETE FROM redbeantables WHERE tablename=\"$table\""); } } } public static function dropColumn( $table, $property ) { if (self::$frozen) { return false; } $db = self::$db; $db->exec("ALTER TABLE `$table` DROP `$property`"); } public static function keepInShape( $gc = false) { if (self::$frozen) { return false; } $db = self::$db; $tables = self::showTables(); if ($tables && is_array($tables) && count($tables) > 0) { if ($gc) self::removeUnused( $tables ); $table = $tables[array_rand( $tables, 1 )]; } else { return; } $table = $db->escape( $table ); if (strpos($table,'_')!==false) return; $cols = $db->get("describe `$table`"); $colr = $cols[array_rand( $cols )]; $col = $db->escape( $colr["Field"] ); if ($col=="id" || strpos($col,"_id")!==false) { return; } $currenttype = self::$sqltype_typeno[$colr["Type"]]; if ($currenttype > 0) { $trytype = rand(0,$currenttype - 1); $db->exec("alter table `$table` add __test  ".self::$typeno_sqltype[$trytype]); $db->exec("update `$table` set __test=`$col`"); $delta = $db->getCell("select count(*) as df from `$table` where
				strcmp(`$col`,__test) != 0 AND `$col` IS NOT NULL"); if (intval($delta)===0) { $sql = "alter table `$table` change `$col` `$col` ".self::$typeno_sqltype[$trytype]; $db->exec($sql); } $db->exec("alter table `$table` drop __test"); } if ( strpos($colr["Type"],"TEXT")!==false || strpos($colr["Type"],"LONGTEXT")!==false ) { return; } $variance = $db->getCell("select count( distinct $col ) from $table"); $records = $db->getCell("select count(*) from $table"); if ($records) { $relvar = intval($variance) / intval($records); $indexname = "reddex_".$col; if ($records > 1 && $relvar > 0.85) { $sqladdindex="ALTER IGNORE TABLE `$table` ADD INDEX $indexname (`$col`)"; $db->exec( $sqladdindex ); } else { $sqldropindex = "ALTER IGNORE TABLE `$table` DROP INDEX $indexname"; $db->exec( $sqldropindex ); } } return true; } }
class Redbean_Querylogger { public static function logSCQuery( $sql ) { $sql = addslashes($sql); $db = Redbean_OODB::$db; $db->exec("INSERT INTO auditsql (id,`sql`) VALUES(null,\"$sql\")"); return null; } }
if (!isset($db)) define("PRFX",""); if (!isset($db)) define("SFFX",""); class RedBean_Setup { public static function kickstart( $dsn="mysql:host=localhost;dbname=oodb", $username='root', $password='', $freeze=false, $engine="innodb", $debugmode=false, $unlockall=false ) { eval("
			class R extends RedBean_OODB { }
		"); eval("
			class RD extends RedBean_Decorator { }
		"); $db = Redbean_Driver_PDO::getInstance( $dsn, $username, $password, null ); if ($debugmode) { $db->setDebugMode(1); } RedBean_OODB::$db = new RedBean_DBAdapter($db); RedBean_OODB::setEngine($engine); RedBean_OODB::init(); if ($unlockall) { RedBean_OODB::resetAll(); } if ($freeze) { RedBean_OODB::freeze(); } } }
class RedBean_Sieve { private $vals; private $report = array(); private $succes = true; public static function make( $validations ) { $sieve = new self; $sieve->vals = $validations; return $sieve; } public function valid( RedBean_Decorator $deco ) { foreach($this->vals as $p => $v) { if (class_exists($v)) { $validator = new $v( $deco, $report ); if ($validator instanceof RedBean_Validator) { $message = $validator->check( $deco->$p ); if ($message !== true) { $this->succes = false; } if (!is_array($this->report[$v])) { $this->report[$v]=array(); } $this->report[ $v ][ $p ] = $message; } } } return $this->succes; } public function validAndReport( RedBean_Decorator $deco, $key=false ) { $this->valid( $deco ); if ($key) { if (isset($this->report[$key])) { return $this->report[$key]; } } return $this->report; } public function getReport() { return $this->report; } }
class Redbean_Tools { private static $class_definitions; private static $remove_whitespaces; public static function walk_dir( $root, $callback, $recursive = true ) { $root = realpath($root); $dh = @opendir( $root ); if( false === $dh ) { return false; } while(false !== ($file = readdir($dh))) { if( "." == $file || ".." == $file ) { continue; } call_user_func( $callback, "{$root}/{$file}" ); if( false !== $recursive && is_dir( "{$root}/{$file}" )) { Redbean_Tools::walk_dir( "{$root}/{$file}", $callback, $recursive ); } } closedir($dh); return true; } public static function compile($file = '', $removeWhiteSpaces = true) { self::$remove_whitespaces = $removeWhiteSpaces; self::$class_definitions = ''; $base = dirname(__FILE__) . '/'; self::walk_dir($base,'Redbean_Tools::stripClassDefinition'); $content = str_replace("\r\n","\n", ' ' . "\n" . file_get_contents($base . 'license.txt') . "\n" . self::$class_definitions); if(!empty($file)) { file_put_contents($file, $content); } return $compiled; } private static function stripClassDefinition($file) { if(is_file($file) && substr($file, -4) == '.php') { if(self::$remove_whitespaces) { self::$class_definitions .= "\n" . trim(str_replace('', '', php_strip_whitespace($file))); } else { self::$class_definitions .= "\n" . trim(str_replace('', '', trim(file_get_contents($file)))); } } } }
class RedBean_Validator_AlphaNumeric implements RedBean_Validator { public function check( $v ) { return (bool) preg_match('/^[A-Za-z0-9]+$/', $v); } }
interface RedBean_Validator { public function check( $property ); }